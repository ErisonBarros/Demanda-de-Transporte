---
title: "Panel and Spatial Regression Models"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      fig.path = "README_files/5-PanelSpatialmodels/")
```

## Panel Regression Models




## Spatial Regression Models

### Moran's I spatial autocorrelation   
#### For polygon geometry

##### Import data
```{r message=FALSE, warning=FALSE}
library(sf)
WIfinal = st_read("Data/Spatial/wi_final_census2_random4.shp") #it is a spatial feature dataset
knitr::kable(head(WIfinal))
```


Let's look at the distribution of *Hispanic people* with a map, using a quantile classification.
```{r warning=FALSE}
library(tmap) #tmap package
tm_shape(WIfinal) + 
  tm_polygons(style = "quantile", col = "HISP_") +
  tm_legend(outside = TRUE, text.size = .8) 
```

##### Neighbors
The first step requires that we define “neighboring” polygons. This could refer to contiguous polygons, polygons within a certain distance band, or it could be non-spatial in nature and defined by social, political or cultural “neighbors”.

Here, we’ll adopt a contiguous neighbor definition where we’ll accept any contiguous polygon that shares at least on vertex (this is the “queen” case and is defined by setting the parameter `queen=TRUE`). If we required that at least one edge be shared between polygons then we would set `queen=FALSE`.
```{r}
library(spdep)
neighbors <- poly2nb(WIfinal, queen=TRUE)
```


##### Weights
Next, we need to assign weights to each neighboring polygon. In this case, each neighboring polygon will be assigned equal weight (`style="W"`). Style can take values “**W**”, “**B**”, “**C**”, “**U**”, “**minmax**” and “**S**”.  
See more details: use `?nb2listw`.
```{r}
weights = nb2listw(neighbors, style="W", zero.policy=TRUE)
```

##### Result
To get the Moran’s I value, simply use the `moran.test` function.
```{r}
moran.test(WIfinal$HISP_, weights)
```

Note that the p-value computed from the `moran.test` function is not computed from an Monte Carlo simulation but analytically instead. This may not always prove to be the most accurate measure of significance.  
To test for significance using the Monte Carlo simulation method instead, use the `moran.mc` function.
```{r}
#for a Monte Carlo simulation with 600 rounds
moran.mc(WIfinal$HISP_, weights, nsim=599)
```

Plot the distribution (note that this is a density plot instead of a histogram).
```{r}
plot(moran.mc(WIfinal$HISP_, weights, nsim=599), main="", las=1) #density plot
```

  
**See more [here](https://mgimond.github.io/Spatial/spatial-autocorrelation-in-r.html)**

  

#### For points
Install and load ape package
```{r message=FALSE, warning=FALSE}
# install.packages("ape")
library(ape)
```

##### Prepare data
It does not deal with ordered factors, zeros, or infinite distances.  
So we need to clean data first.
```{r eval=F}
str(TABLE)
TABLE$classfactor<-as.numeric(TABLE$CLASS) #make ordered factors as numeric
TABLE$classfactor<-factor(TABLE$classfactor)
TABLEmoran<-TABLE
TABLEmoran$geometry<-NULL #drop geometry
TABLEmoran<-na.omit(TABLEmoran) #remove cases with NA
TABLEmoran<-TABLEmoran[TABLEmoran$Orig_Lat!=0,] #Remove cases with Lat/Lon equals to zero
```

##### Distances matrix, from coordinates (Lat Long)
To calculate Moran’s I, we will need to generate a matrix of inverse distance weights. In the matrix, entries for pairs of points that are close together are higher than for pairs of points that are far apart. 
  
We can first generate a distance matrix, then take inverse of the matrix values and replace the diagonal entries with zero:
```{r eval=F}
ozone.dists <- as.matrix(dist(cbind(TABLEmoran$Orig_Long, TABLEmoran$Orig_Lat)))
ozone.dists.inv <- 1/ozone.dists
diag(ozone.dists.inv) <- 0 #diagonal as zero
ozone.dists.inv[is.infinite(ozone.dists.inv)] <- 0 #remove infinite distances
```
We have created a matrix where each off-diagonal entry [ _i_, _j_] in the matrix is equal to 1/(distance between point _i_ and point _j_). Note that this is just one of several ways in which we can calculate an inverse distance matrix.  

##### Result
We can now calculate Moran’s I using the command `Moran.I`.
```{r eval=F}
#First attempt
Moran.I(TABLEmoran$classfactor, ozone.dists.inv)
#Remove distances over 15 km
ozone.dists.bin <- (ozone.dists > 0 & ozone.dists <= 15000)

#Second attempt
Moran.I(TABLEmoran$classfactor, ozone.dists.bin) #Moran’s I =0.012, p = .001
```

>The result (observed) is the Moran's I value, and if it is enough close to zero, we can affirm (with p=...) that ther is not a spatial pattern, suggesting an aleatory distribution in space.
Tf the result was close to 1 or -1, it would suggest a pattern in distribuition in space.


**See more [here](https://stats.idre.ucla.edu/r/faq/how-can-i-calculate-morans-i-in-r/)**